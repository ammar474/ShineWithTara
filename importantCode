  // this code use in future when i doing some consdition on multer or image process
const multer = require('multer');
const path = require('path');

// Setup Multer storage to save files in 'public/uploads'
const storage = multer.diskStorage({
    destination: function (req, file, cb) {
        cb(null, path.join(__dirname, 'public/uploads'));  // Save files in 'public/uploads' folder
    },
    filename: function (req, file, cb) {
        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
        const fileExtension = path.extname(file.originalname);  // Get file extension
        cb(null, file.fieldname + '-' + uniqueSuffix + fileExtension);  // Define the filename
    }
});

// Initialize Multer
const upload = multer({
    storage: storage,
    limits: { fileSize: 5 * 1024 * 1024 },  // Optional: Set file size limit (5MB here)
    fileFilter: function (req, file, cb) {
        const fileTypes = /jpeg|jpg|png|gif/;
        const extname = fileTypes.test(path.extname(file.originalname).toLowerCase());
        const mimeType = fileTypes.test(file.mimetype);

        if (mimeType && extname) {
            return cb(null, true);
        } else {
            cb(new Error('Only images are allowed!'));
        }
    }
});




 //    const items = {
   //     product_id : req.body.items[0].id, 
   //     productName : req.body.items[0].name,
   //     price : req.body.items[0].price, 
   //     quantity : req.body.items[0].quantity,
   //     image : req.body.items[0].image 
   //   }  



//    const multer = require('multer');
// const path = require('path');
// const fs = require('fs');

// const storage = multer.diskStorage({
//     destination: (req, file, cb) => {
//         cb(null, 'public/uploads/');
//     },
//     filename: (req, file, cb) => {
//         cb(null, Date.now() + path.extname(file.originalname));
//     }
// });

// const upload = multer({ storage: storage

// validate  input field  
exports.validateInput = (requiredFields, reqBody) => {
  const missingFields = requiredFields.filter(field => !reqBody[field]);
  if (missingFields.length > 0) {
    return `Missing fields: ${missingFields.join(', ')}`;
  }
  return null;
};

// in controller 
const { validateInput } = require('../utils/helpers');

const error = validateInput(['name', 'email', 'password'], req.body);
if (error) {
  return res.status(400).json({ message: error });
}

  

  


 




import React, { useState, useEffect } from 'react';
import axios from 'axios';

const PaginatedList = () => {
  const [products, setProducts] = useState([]);
  const [currentPage, setCurrentPage] = useState(1); // Initial page
  const [limit, setLimit] = useState(10); // Initial limit (items per page)
  const [totalPages, setTotalPages] = useState(0);

  // Fetch data when `currentPage` or `limit` changes
  useEffect(() => {
    fetchProducts(currentPage, limit);
  }, [currentPage, limit]);

  // API call to fetch products with pagination
  const fetchProducts = async (page, limit) => {
    try {
      const response = await axios.get(`/api/products?page=${page}&limit=${limit}`);
      setProducts(response.data.data);
      setTotalPages(response.data.totalPages);
    } catch (error) {
      console.error('Error fetching products:', error);
    }
  };

  // Handle page change
  const handlePageChange = (newPage) => {
    setCurrentPage(newPage);
  };

  // Handle limit change (items per page)
  const handleLimitChange = (event) => {
    setLimit(event.target.value);
    setCurrentPage(1); // Reset to first page when limit changes
  };

  return (
    <div>
      <div>
        <label>Items per page: </label>
        <select value={limit} onChange={handleLimitChange}>
          <option value={5}>5</option>
          <option value={10}>10</option>
          <option value={20}>20</option>
        </select>
      </div>

      <ul>
        {products.map((product) => (
          <li key={product._id}>{product.name}</li>
        ))}
      </ul>

      <div className="pagination">
        <button
          onClick={() => handlePageChange(currentPage - 1)}
          disabled={currentPage === 1}
        >
          Previous
        </button>

        {[...Array(totalPages).keys()].map((num) => (
          <button
            key={num + 1}
            onClick={() => handlePageChange(num + 1)}
            className={currentPage === num + 1 ? 'active' : ''}
          >
            {num + 1}
          </button>
        ))}

        <button
          onClick={() => handlePageChange(currentPage + 1)}
          disabled={currentPage === totalPages}
        >
          Next
        </button>
      </div>
    </div>
  );
};

export default PaginatedList;

// get oderes of user 
export const GetOrdersByUserId = async (req, res) => {
  const userId = req.data.userId; // Assuming req.data holds the authenticated user's ID

  try {
    const orders = await Order.find({ userId }).sort({ createdAt: -1 }); // Get orders by userId
    if (orders.length > 0) {
      return res.status(200).send({ orders });
    } else {
      return res.status(404).send({ message: "No orders found for this user" });
    }
  } catch (error) {
    console.log(error);
    return res.status(500).send({ message: error.message });
  }
};




export const AddOrder = async (req, res) => {
  const { firstName, lastName, email, phone, address, items, totalAmount ,  } = req.body;
  const userId = req.data.userId; // Assuming `req.data` holds the authenticated user's ID

  if (!firstName || !lastName || !email || !phone || !address || !items || !totalAmount) {
    return res.status(400).send({ message: "Fill the field properly" });
  }

  const item = {
    product_id: items[0].id,
    productName: items[0].name,
    price: items[0].price,
    quantity: items[0].quantity,
    image: items[0].image,
  };

  try {
    const addOrder = new Order({
      userId, // Attach the userId to the order
      firstName,
      lastName,
      email,
      phone,
      address,
      items: item,
      totalAmount,
    });

    const newOrder = await addOrder.save();
    if (newOrder) {
      return res.status(200).send({ order: newOrder });
    } else {
      return res.status(400).send({ message: "Add order properly" });
    }
  } catch (error) {
    console.log(error);
    res.status(500).send({ error: error.message });
  }
};


import mongoose from "mongoose";

const orderSchema = new mongoose.Schema(
  {
    userId: { type: mongoose.Schema.Types.ObjectId, ref: "User", required: true }, // Link to the User model
    firstName: String,
    lastName: String,
    email: String,
    phone: String,
    address: String,
    items: [
      {
        product_id: String,
        productName: String,
        price: Number,
        quantity: Number,
        image: String,
      },
    ],
    totalAmount: Number,
    orderStatus: { type: String, default: "Processing" },
  },
  { timestamps: true }
);

export const Order = mongoose.model("Order", orderSchema);